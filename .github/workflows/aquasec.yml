name: KubeEnforcer / PodEnforcer on EKS with Fargate profile

on:
  push:
    branches: [ "main" ]

env:
  AWS_REGION:   us-west-1                   
  EKS_CLUSTER:  AndreasMCluster2
  NAMESPACE:    aqua
  # ECR_REPOSITORY: andreasm                
  # ECS_SERVICE: MESidecar                  
  # ECS_TASK_DEFINITION: AndreasM-ME-Sidecar

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: installing eksctl
      run:  |
            curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
            sudo mv /tmp/eksctl /usr/local/bin
            eksctl version

    - name: Check if the cluster already exists  ##assuming the service also exists without checking
      id: ClusterExists
      run: echo "result=$(aws ecs list-clusters --region ${{ env.AWS_REGION }} --query "contains(clusterArns,'arn:aws:ecs:${{ env.AWS_REGION }}:633291361733:cluster/${{ env.EKS_CLUSTER }}')")" >> $GITHUB_OUTPUT          
     
### Wenn Cluster noch nicht existiert 
    - name: create an EKS cluster with Fargate profile
      if: steps.ClusterExists.outputs.result == 'false'
      run:  |
            eksctl create cluster \
            --name ${{ env.EKS_CLUSTER }} \
            --region ${{ env.AWS_REGION }} \
            --fargate --version 1.27

    - name: configure kubectl
      if: steps.ClusterExists.outputs.result == 'true'
      run:  |
            aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
            kubectl version --client=true -o json | jq '.clientVersion.gitVersion' -r 
            kubectl get nodes -o wide
            kubectl get pods -A -o wide

    - name: create namespace for Aqua with fargateprofile   
      if: steps.ClusterExists.outputs.result == 'true'
      run:  |
            kubectl create ns ${{ env.NAMESPACE }}

            eksctl create fargateprofile \
                --cluster ${{ env.EKS_CLUSTER }} \
                --name aqua-fargate-profile \
                --namespace ${{ env.NAMESPACE }} \
                --labels key=value
            
    - name: helm
      if: steps.ClusterExists.outputs.result == 'true'
      run:  |
            helm repo add aqua-helm https://helm.aquasec.com
            helm repo update
            helm search repo aqua-helm
            helm upgrade --install --namespace ${{ env.NAMESPACE }} kube-enforcer aqua-helm/kube-enforcer --version 2022.4 -f ./kube-enforcer-values.yaml
            ## In Fargate the fargate-profile needs to be created first. Once this is created, the namespace can be created, and everything works.
            ## sa https://stackoverflow.com/questions/73949730/eks-pod-in-workspace-getting-default-scheduler-for-fargate
            ## noch keine Ahnung, wie das geht - irgendwie https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html#create-fargate-profile
            ## helm upgrade --install --namespace default kube-enforcer aqua-helm/kube-enforcer --version 2022.4 -f ./kube-enforcer-values.yaml

    - name: deploy some workload   
      if: steps.ClusterExists.outputs.result == 'true'
      run:  |
            kubectl create deployment netshoot --image=nicolaka/netshoot -- "/bin/sleep" "infinity"

    - name: Utilities
      run: |
          echo CloudFormation:
          echo "https://us-west-1.console.aws.amazon.com/cloudformation/home?region=us-west-1#/stacks?filteringText=&filteringStatus=active&viewNested=true"
          echo
          echo "eksctl delete cluster --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}"


# ## fÃ¼r aws cli output in bash (sa https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-pagination.html#cli-usage-pagination-clientside)
# ## default ist: export AWS_PAGER="less" - zum deaktivieren: export AWS_PAGER="" - oder aws ... --no-cli-pager
# ## aws ecs stop-task --cluster AndreasMCluster --region us-west-1 --task b60c0efe4d914af197bc2b0268780ca4
# ##
# ## aws ecs list-services --region us-west-1 --cluster AndreasMCluster
# ## aws ecs update-service --region us-west-1 --cluster AndreasMCluster --service MESidecar --desired-count 0
# ## aws ecs delete-service --region us-west-1 --cluster AndreasMCluster --service MESidecar
# ## aws ecs delete-cluster --region us-west-1 --cluster AndreasMCluster 
# ##
# ## aws ecs list-task-definitions --region us-west-1 --family-prefix AndreasM-ME-Sidecar --no-cli-pager
# ## aws ecs deregister-task-definition --region us-west-1 --task-definition arn:aws:ecs:us-west-1:633291361733:task-definition/AndreasM-ME-Sidecar:6
# #

# ## App + ME images frisch runterladen und auf ECR hochladen
    # - name: Login to Amazon ECR
      # id: login-ecr
      # uses: aws-actions/amazon-ecr-login@v1

    # - name: pull / push App Image to Amazon ECR
      # id: app-image
      # env:
        # Image:            nginx
        # Tag:              latest
        # ECR_REPOSITORY:   ${{ env.ECR_REPOSITORY }}
        # ECR_REGISTRY:     ${{ steps.login-ecr.outputs.registry }}
      # run: |
        # docker pull $Image:$Tag
        # docker tag $Image:$Tag $ECR_REGISTRY/$ECR_REPOSITORY:$Image
        # docker push $ECR_REGISTRY/$ECR_REPOSITORY:$Image
        # echo "app_image=$ECR_REGISTRY/$ECR_REPOSITORY:$Image" >> $GITHUB_OUTPUT

    # - name: Login to registry.aquasec.com
      # id: login-registry-aquasec-com
      # uses: docker/login-action@v3
      # with:
        # registry: registry.aquasec.com
        # username: ${{ secrets.AQUA_USER }}
        # password: ${{ secrets.AQUA_PASSWORD }}

    # - name: pull / push ME Sidecar Image to Amazon ECR
      # id: me-image
      # env:
        # Registry:         registry.aquasec.com
        # Image:            microenforcer-basic
        # Tag:              2022.4
        # ECR_REPOSITORY:   ${{ env.ECR_REPOSITORY }}
        # ECR_REGISTRY:     ${{ steps.login-ecr.outputs.registry }}
        # AQUA_REGISTRY:    ${{ steps.login-registry-aquasec-com.outputs.registry }}
      # run: |
        # docker pull $Registry/$Image:$Tag
        # docker tag $Registry/$Image:$Tag $ECR_REGISTRY/$ECR_REPOSITORY:$Image
        # docker push $ECR_REGISTRY/$ECR_REPOSITORY:$Image
        # echo "me_image=$ECR_REGISTRY/$ECR_REPOSITORY:$Image" >> $GITHUB_OUTPUT
        
    # - name: Utilities
      # run: |
          # echo ECR password:
          # echo "user: AWS"
          # echo "password: $(aws ecr get-login-password --region us-west-1)"
          # echo
          # echo optional AQUA_IMAGE_ID:
          # echo "$(docker image inspect --format {{.Id}} ${{ steps.app-image.outputs.app_image }})"
          
    # - name: Check if the cluster already exists  ##assuming the service also exists without checking
      # id: ClusterExists
      # run: echo "result=$(aws ecs list-clusters --region us-west-1 --query "contains(clusterArns,'arn:aws:ecs:us-west-1:633291361733:cluster/${{ env.ECS_CLUSTER }}')")" >> $GITHUB_OUTPUT          
   
     
# ### Wenn Cluster noch nicht existiert 
    # - name: aws ecs create-cluster
      # if: steps.ClusterExists.outputs.result == 'false'
      # run: aws ecs create-cluster --cluster-name ${{ env.ECS_CLUSTER }} --region ${{ env.AWS_REGION }} --capacity-providers FARGATE 
        
# #    - name: run FARGATE task
# #      run: aws ecs run-task --cluster AndreasMCluster --task-definition AndreasMmeSidecar:21 --launch-type="FARGATE" --region us-west-1 --network-configuration '{"awsvpcConfiguration":{"assignPublicIp":"ENABLED","securityGroups":["sg-0b323ecaeb5d39379"],"subnets":["subnet-046ad0cd38c7e05cb","subnet-0b0db515a07b3a402","subnet-02081b7a023f2661f","subnet-070627f825b1ca7a5","subnet-09f04cf8eda5f7f00","subnet-0428c45315633c12f","subnet-0ed8ad693f0ac237e","subnet-0b774184c69364847"]}}'

    # - name: register task definition
      # if: steps.ClusterExists.outputs.result == 'false'
      # run: aws ecs register-task-definition --region ${{ env.AWS_REGION }} --family ${{ env.ECS_TASK_DEFINITION }} --cli-input-json file://MeSidecar-task-definition.json --tags key="AndreasM",value="true"
     
    # - name: create service on cluster # using predefined Aqua Subnets
      # if: steps.ClusterExists.outputs.result == 'false'
      # run: aws ecs create-service --region ${{ env.AWS_REGION }} --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_SERVICE }} --task-definition ${{ env.ECS_TASK_DEFINITION }} --desired-count 1 --launch-type FARGATE --platform-version LATEST --network-configuration '{"awsvpcConfiguration":{"assignPublicIp":"ENABLED","securityGroups":["sg-0b323ecaeb5d39379"],"subnets":["subnet-046ad0cd38c7e05cb","subnet-0b0db515a07b3a402","subnet-02081b7a023f2661f","subnet-070627f825b1ca7a5","subnet-09f04cf8eda5f7f00","subnet-0428c45315633c12f","subnet-0ed8ad693f0ac237e","subnet-0b774184c69364847"]}}'

  
# ### Wenn Cluster schon existiert, neue Task Definition aus Template anlegen und Task im existierenden Cluster und Service starten
    # - name: Deploy Task to ECS (on existing cluster / service)
      # if: steps.ClusterExists.outputs.result == 'true'
      # uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      # env:
        # AWS_REGION: us-west-1
      # with:
        # task-definition: MeSidecar-task-definition.json
        # service: ${{ env.ECS_SERVICE }}
        # cluster: ${{ env.ECS_CLUSTER }}
        # wait-for-service-stability: true